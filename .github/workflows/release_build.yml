name: Release Build
on:
  push:
  workflow_dispatch:
    inputs:
      version:
        description: The version to tag the release with, e.g., 1.2.0
        required: true

env:
  AWS_DEFAULT_REGION: us-east-1
  AWS_PUBLIC_ECR_REGION: us-east-1
  AWS_PRIVATE_ECR_REGION: us-west-2
  AWS_SIGNING_KEY_REGION: us-west-2
  RELEASE_PUBLIC_REPOSITORY: public.ecr.aws/aws-observability/adot-autoinstrumentation-dotnet
  RELEASE_PRIVATE_REPOSITORY: 020628701572.dkr.ecr.us-west-2.amazonaws.com/adot-autoinstrumentation-dotnet
  RELEASE_PRIVATE_REGISTRY: 020628701572.dkr.ecr.us-west-2.amazonaws.com
  RELEASE_PRIVATE_S3: s3://adot-autoinstrumentation-dotnet-staging

permissions:
  id-token: write
  contents: write

jobs:
  build-and-upload:
    strategy:
      fail-fast: false
      matrix:
        aws-region: [ 'us-east-1' ]
    uses: ./.github/workflows/main_build.yml
    secrets: inherit
    with:
      caller-workflow-name: 'release_build_workflow'

  release:
    needs: [build-and-upload, build-release-nuget]
    environment: Release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Contrib Repo @ SHA - ${{ github.sha }}
        uses: actions/checkout@v4

      - name: Download Linux x64 Artifact
        uses: actions/download-artifact@v3
        with:
          name: aws-distro-opentelemetry-dotnet-instrumentation-linux-glibc-x64.zip
          path: ./artifacts/linux/x64

      # - name: Download Linux arm64 Artifact
      #   uses: actions/download-artifact@v3
      #   with:
      #     name: aws-distro-opentelemetry-dotnet-instrumentation-linux-glibc-arm64.zip
      #     path: ./artifacts/linux/arm64

      - name: Download Windows Artifact
        uses: actions/download-artifact@v3
        with:
          name: aws-distro-opentelemetry-dotnet-instrumentation-windows.zip
          path: ./artifacts/windows

      - name: Download Linux X64 MUSL Artifact
        uses: actions/download-artifact@v3
        with:
          name: aws-distro-opentelemetry-dotnet-instrumentation-linux-musl-x64.zip
          path: ./artifacts/linux/x64-musl
      
      # - name: Download Linux arm64 MUSL Artifact
      #   uses: actions/download-artifact@v3
      #   with:
      #     name: aws-distro-opentelemetry-dotnet-instrumentation-linux-musl-arm64.zip
      #     path: ./artifacts/linux/arm64-musl

      - name: Download bash installation script
        uses: actions/download-artifact@v3
        with:
          name: aws-otel-dotnet-install.sh
          path: ./installationScripts
      
      - name: Download psm1 installation script
        uses: actions/download-artifact@v3
        with:
          name: AWS.Otel.DotNet.Auto.psm1
          path: ./installationScripts
      
      - name: Download nuget package
        uses: actions/download-artifact@v3
        with:
          name: nuget-packages.zip
          path: ./artifacts/nuget

      # - name: Configure AWS credentials for Private S3 Bucket
      #   uses: aws-actions/configure-aws-credentials@v4
      #   with:
      #     role-to-assume: ${{ secrets.AWS_ASSUME_ROLE_ARN }}
      #     aws-region: ${{ env.AWS_DEFAULT_REGION }}

      # - name: Upload to Private S3 Bucket
      #   run: |
      #     PREFIX="Release_v0.0.0"

      #     find ./artifacts/ -name "*.zip" | while read file; do
      #     base=$(basename "$file")
      #     aws s3 cp "$file" "${{ env.RELEASE_PRIVATE_S3 }}/$PREFIX/$base"
      #     done
      #     aws s3 cp ./installationScripts/aws-otel-dotnet-install.sh "${{ env.RELEASE_PRIVATE_S3 }}/$PREFIX/aws-otel-dotnet-install.sh"
      #     aws s3 cp ./installationScripts/AWS.Otel.DotNet.Auto.psm1 "${{ env.RELEASE_PRIVATE_S3 }}/$PREFIX/AWS.Otel.DotNet.Auto.psm1"
      #     aws s3 cp ./artifacts/nuget/nuget-packages.zip "${{ env.RELEASE_PRIVATE_S3 }}/$PREFIX/nuget-packages.zip"

      # Publish to GitHub releases
      - name: Create GH release
        id: create_release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # This token is provided by Actions, you do not need to create your own token
        run: |
          gh release create --target "$GITHUB_REF_NAME" \
             --title "Release v${{ github.event.inputs.version }}" \
             "v${{ github.event.inputs.version }}" \
              --notes "Release Verions v${{ github.event.inputs.version }}"

      - name: Upload artifacts and checksum to release 
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PREFIX="Release_v0.0.0_"

          find ./artifacts/ -name "*.zip" | while read file; do
          base=$(basename "$file")
          cp "$file" "$base"
          shasum -a 256 $base > $base.sha256
          gh release upload "v${{ github.event.inputs.version }}" \
            $base \
            $base.sha256 \
            --clobber
          done
          shasum -a 256 ./installationScripts/aws-otel-dotnet-install.sh | sed "s|./installationScripts/||" > aws-otel-dotnet-install.sh.sha256
          shasum -a 256 ./installationScripts/AWS.Otel.DotNet.Auto.psm1 | sed "s|./installationScripts/||" > AWS.Otel.DotNet.Auto.psm1.sha256
          shasum -a 256 ./artifacts/nuget/nuget-packages.zip | sed "s|./artifacts/nuget/||" > nuget-packages.zip.sha256
          gh release upload "v${{ github.event.inputs.version }}" \
            ./installationScripts/aws-otel-dotnet-install.sh \
            aws-otel-dotnet-install.sh.sha256 \
            --clobber
          gh release upload "v${{ github.event.inputs.version }}" \
            ./installationScripts/AWS.Otel.DotNet.Auto.psm1 \
            AWS.Otel.DotNet.Auto.psm1.sha256 \
            --clobber
          gh release upload "v${{ github.event.inputs.version }}" \
            ./artifacts/nuget/nuget-packages.zip \
            nuget-packages.zip.sha256 \
            --clobber

  # release-image:
  #   # We want to build and release nuget first so that if it fails, it fails before publishing to private ECR
  #   # since deleting from Private ECR is not possible.
  #   needs: [release, build-release-nuget]
  #   runs-on: ${{ matrix.os }}
  #   continue-on-error: true
  #   strategy:
  #     matrix:
  #       include:
  #         - os: windows-2022
  #         - os: windows-2019
  #         - os: ubuntu-latest
  #   steps:
  #     - uses: actions/checkout@v3

  #     - name: Download Linux x64 Artifact
  #       if: runner.os == 'Linux'
  #       uses: actions/download-artifact@v3
  #       with:
  #         name: aws-distro-opentelemetry-dotnet-instrumentation-linux-glibc-x64.zip
  #         path: ./artifacts/linux/x64

  #     - name: Download Linux X64 MUSL Artifact
  #       if: runner.os == 'Linux'
  #       uses: actions/download-artifact@v3
  #       with:
  #         name: aws-distro-opentelemetry-dotnet-instrumentation-linux-musl-x64.zip
  #         path: ./artifacts/linux/x64-musl

  #     - name: Download Linux arm64 Artifact
  #       if: runner.os == 'Linux'
  #       uses: actions/download-artifact@v3
  #       with:
  #         name: aws-distro-opentelemetry-dotnet-instrumentation-linux-glibc-arm64.zip
  #         path: ./artifacts/linux/arm64

  #     - name: Download Linux arm64 MUSL Artifact
  #       if: runner.os == 'Linux'
  #       uses: actions/download-artifact@v3
  #       with:
  #         name: aws-distro-opentelemetry-dotnet-instrumentation-linux-musl-arm64.zip
  #         path: ./artifacts/linux/arm64-musl

  #     - name: Unzip Linux Artifact
  #       if: runner.os == 'Linux'
  #       run: |
  #         unzip ./artifacts/linux/x64/*.zip -d ./OpenTelemetryDistribution
  #         unzip ./artifacts/linux/x64-musl/*.zip "linux-musl-x64/*" -d ./OpenTelemetryDistribution
  #         mkdir ./arm64
  #         unzip ./artifacts/linux/arm64/*.zip -d ./arm64/OpenTelemetryDistribution
  #         unzip ./artifacts/linux/arm64-musl/*.zip "linux-musl-arm64/*" -d ./arm64/OpenTelemetryDistribution

  #     - name: Download Windows Artifact
  #       if: runner.os == 'Windows'
  #       uses: actions/download-artifact@v3
  #       with:
  #         name: aws-distro-opentelemetry-dotnet-instrumentation-windows.zip
  #         path: ./artifacts/windows

  #     - name: Unzip Windows Artifact
  #       if: runner.os == 'Windows'
  #       run: |
  #         Expand-Archive -LiteralPath .\artifacts\windows\aws-distro-opentelemetry-dotnet-instrumentation-windows.zip -DestinationPath .\OpenTelemetryDistribution -Force
  #       shell: powershell


  #     - name: Configure AWS credentials for public ECR
  #       uses: aws-actions/configure-aws-credentials@v4
  #       with:
  #         role-to-assume: ${{ secrets.AWS_ROLE_ARN_ECR_RELEASE }}
  #         aws-region: ${{ env.AWS_PUBLIC_ECR_REGION }}

  #     # https://github.com/docker/docker-credential-helpers/issues/190
  #     - name: Fix Public ECR login issue on GitHub Windows Runner
  #       if: runner.os == 'Windows'
  #       run: |
  #         echo '{"auths": {"https://index.docker.io/v1/": {}}, "HttpHeaders": { "User-Agent": "Docker-Client/19.03.12 (windows)"}}' | out-file -encoding ASCII ~/.docker/config.json
  #       shell: powershell

  #     - name: Login to Amazon public ECR
  #       id: login-ecr-public
  #       uses: aws-actions/amazon-ecr-login@v2
  #       with:
  #         registry-type: public

  #     - name: Configure AWS credentials for private ECR
  #       uses: aws-actions/configure-aws-credentials@v4
  #       with:
  #         role-to-assume: ${{ secrets.AWS_ROLE_ARN_ECR_RELEASE }}
  #         aws-region: ${{ env.AWS_PRIVATE_ECR_REGION }}

  #     - name: Login to Amazon private ECR
  #       id: login-ecr
  #       uses: aws-actions/amazon-ecr-login@v2

  #     - name: Build Linux container
  #       if: runner.os == 'Linux'
  #       run: |
  #         set -e
  #         docker build -t ${{ env.RELEASE_PRIVATE_REPOSITORY }}:v${{ github.event.inputs.version }}-amd64 -f ./Dockerfile.linux .
  #         docker push ${{ env.RELEASE_PRIVATE_REPOSITORY }}:v${{ github.event.inputs.version }}-amd64
  #         docker tag ${{ env.RELEASE_PRIVATE_REPOSITORY }}:v${{ github.event.inputs.version }}-amd64 ${{ env.RELEASE_PUBLIC_REPOSITORY }}:v${{ github.event.inputs.version }}-amd64
  #         docker push ${{ env.RELEASE_PUBLIC_REPOSITORY }}:v${{ github.event.inputs.version }}-amd64

  #     - name: Build Linux arm64 container
  #       if: runner.os == 'Linux'
  #       run: |
  #         set -e
  #         cp THIRD-PARTY-LICENSES ./arm64/THIRD-PARTY-LICENSES
  #         cd ./arm64
  #         docker build --platform linux/arm64 -t ${{ env.RELEASE_PRIVATE_REPOSITORY }}:v${{ github.event.inputs.version }}-arm64 -f ../Dockerfile.linux .
  #         docker push ${{ env.RELEASE_PRIVATE_REPOSITORY }}:v${{ github.event.inputs.version }}-arm64
  #         docker tag ${{ env.RELEASE_PRIVATE_REPOSITORY }}:v${{ github.event.inputs.version }}-arm64 ${{ env.RELEASE_PUBLIC_REPOSITORY }}:v${{ github.event.inputs.version }}-arm64
  #         docker push ${{ env.RELEASE_PUBLIC_REPOSITORY }}:v${{ github.event.inputs.version }}-arm64

  #     - name: Build Windows container
  #       if: runner.os == 'Windows'
  #       run: |
  #         $osInfo = systeminfo | Select-String "OS Version"
  #         if ($osInfo -match "10.0.17763") {
  #           Echo "Build image for Windows Server 2019"
  #           docker build -t ${{ env.RELEASE_PRIVATE_REPOSITORY }}:v${{ github.event.inputs.version }}-windows2019 -f ./Dockerfile.windows2019 .
  #           docker push ${{ env.RELEASE_PRIVATE_REPOSITORY }}:v${{ github.event.inputs.version }}-windows2019
  #           docker tag ${{ env.RELEASE_PRIVATE_REPOSITORY }}:v${{ github.event.inputs.version }}-windows2019 ${{ env.RELEASE_PUBLIC_REPOSITORY }}:v${{ github.event.inputs.version }}-windows2019
  #           docker push ${{ env.RELEASE_PUBLIC_REPOSITORY }}:v${{ github.event.inputs.version }}-windows2019
  #         } elseif ($osInfo -match "10.0.20348") {
  #           Echo "Build image for Windows Server 2022"
  #           docker build -t ${{ env.RELEASE_PRIVATE_REPOSITORY }}:v${{ github.event.inputs.version }}-windows2022 -f ./Dockerfile.windows2022 .
  #           docker push ${{ env.RELEASE_PRIVATE_REPOSITORY }}:v${{ github.event.inputs.version }}-windows2022
  #           docker tag ${{ env.RELEASE_PRIVATE_REPOSITORY }}:v${{ github.event.inputs.version }}-windows2022 ${{ env.RELEASE_PUBLIC_REPOSITORY }}:v${{ github.event.inputs.version }}-windows2022
  #           docker push ${{ env.RELEASE_PUBLIC_REPOSITORY }}:v${{ github.event.inputs.version }}-windows2022
  #         } else {
  #             Echo "Unknown Windows Server version: $osInfo"
  #             exit 1
  #         }
  #       shell: powershell

  # release-multi-platform-image:
  #   needs: [release-image]
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Configure AWS credentials for private ECR
  #       uses: aws-actions/configure-aws-credentials@v4
  #       with:
  #         role-to-assume: ${{ secrets.AWS_ROLE_ARN_ECR_RELEASE }}
  #         aws-region: ${{ env.AWS_PRIVATE_ECR_REGION }}

  #     - name: Log in to AWS private ECR
  #       uses: docker/login-action@v3
  #       with:
  #         registry: ${{ env.RELEASE_PRIVATE_REGISTRY }}

  #     - name: Configure AWS credentials for public ECR
  #       uses: aws-actions/configure-aws-credentials@v4
  #       with:
  #         role-to-assume: ${{ secrets.AWS_ROLE_ARN_ECR_RELEASE }}
  #         aws-region: ${{ env.AWS_PUBLIC_ECR_REGION }}

  #     - name: Log in to AWS public ECR
  #       uses: docker/login-action@v3
  #       with:
  #         registry: public.ecr.aws

  #     - name: Create multi-platform image and push to Amazon private ECR
  #       run: |
  #         docker manifest create ${{ env.RELEASE_PRIVATE_REPOSITORY }}:v${{ github.event.inputs.version }} ${{ env.RELEASE_PRIVATE_REPOSITORY }}:v${{ github.event.inputs.version }}-amd64 ${{ env.RELEASE_PRIVATE_REPOSITORY }}:v${{ github.event.inputs.version }}-arm64 ${{ env.RELEASE_PRIVATE_REPOSITORY }}:v${{ github.event.inputs.version }}-windows2019 ${{ env.RELEASE_PRIVATE_REPOSITORY }}:v${{ github.event.inputs.version }}-windows2022
  #         docker manifest inspect ${{ env.RELEASE_PRIVATE_REPOSITORY }}:v${{ github.event.inputs.version }}
  #         docker manifest push ${{ env.RELEASE_PRIVATE_REPOSITORY }}:v${{ github.event.inputs.version }}

  #     - name: Create multi-platform image and push to Amazon public ECR
  #       run: |
  #         docker manifest create ${{ env.RELEASE_PUBLIC_REPOSITORY }}:v${{ github.event.inputs.version }} ${{ env.RELEASE_PUBLIC_REPOSITORY }}:v${{ github.event.inputs.version }}-amd64 ${{ env.RELEASE_PUBLIC_REPOSITORY }}:v${{ github.event.inputs.version }}-arm64 ${{ env.RELEASE_PUBLIC_REPOSITORY }}:v${{ github.event.inputs.version }}-windows2019 ${{ env.RELEASE_PUBLIC_REPOSITORY }}:v${{ github.event.inputs.version }}-windows2022
  #         docker manifest inspect ${{ env.RELEASE_PUBLIC_REPOSITORY }}:v${{ github.event.inputs.version }}
  #         docker manifest push ${{ env.RELEASE_PUBLIC_REPOSITORY }}:v${{ github.event.inputs.version }}

  build-release-nuget:
    runs-on: windows-latest

    strategy:
        fail-fast: true

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
        
      - name: Install dependencies
        run: dotnet restore .\src\AWS.Distro.OpenTelemetry.AutoInstrumentation /p:_IsPacking=true

      - name: Build solution
        run: >
          dotnet build .\src\AWS.Distro.OpenTelemetry.AutoInstrumentation
          /p:Configuration=Release
          --no-restore

      # - name: Assume signer role
      #   uses: aws-actions/configure-aws-credentials@v1
      #   with:
      #     role-to-assume: ${{ secrets.AWS_ARTIFACT_ACCESS_ROLE_ARN }}
      #     aws-region: ${{ env.AWS_SIGNING_KEY_REGION }}

      # - name: Invoke Signing script
      #   env:
      #     UNSIGNED_BUCKET: ${{ secrets.AWS_UNSIGNED_BUCKET_NAME }}
      #     SIGNED_BUCKET: ${{ secrets.AWS_SIGNED_BUCKET_NAME }}
      #   #TODO: There is probably a better way to pass in a list of paths as a single parameter to the script.
      #   run: |
      #     .\buildtools\sign_files.ps1 -Filters AWS.Distro.OpenTelemetry.AutoInstrumentation.dll -Recurse -Path .\src\AWS.Distro.OpenTelemetry.AutoInstrumentation\bin\Release
      #     .\buildtools\sign_files.ps1 -Filters OpenTelemetry.Instrumentation.AWS.dll -Recurse -Path .\src\AWS.Distro.OpenTelemetry.AutoInstrumentation\bin\Release
          
      - name: Pack nugets
        run: >
          dotnet pack
          .\src\AWS.Distro.OpenTelemetry.AutoInstrumentation
          /p:Version=0.0.0
          --no-build
          -c Release
          -o .\Deployment\nuget-packages

      - name: Upload nugets to this GitHub Action run as an artifact
        uses: actions/upload-artifact@v3
        with:
          name: nuget-packages.zip
          path: Deployment/nuget-packages/

      # - name: Assume nuget role
      #   uses: aws-actions/configure-aws-credentials@v1
      #   with:
      #     role-to-assume: ${{ secrets.NUGET_ACCESS_ROLE_ARN }}
      #     aws-region: ${{ env.AWS_SIGNING_KEY_REGION }}

      # - name: Push packages to Nuget.org
      #   run: >
      #     $nugetKey = aws secretsmanager get-secret-value
      #     --secret-id ${{ secrets.NUGET_SECRETS_ID }}
      #     --region ${{ env.AWS_SIGNING_KEY_REGION }}
      #     --output text
      #     --query SecretString | ConvertFrom-Json

      #     nuget push
      #     .\Deployment\nuget-packages\*.nupkg
      #     -Source https://api.nuget.org/v3/index.json
      #     -ApiKey $nugetKey.Key